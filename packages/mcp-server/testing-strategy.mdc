---
description: |
  Testing strategy focusing on API validation over automated tests. Use analyze_feature after 
  implementation, fix errors, then test via API requests. Apply when: feature complete, 
  post-implementation validation, API testing, avoiding unnecessary test file creation.
globs: ["**/*.ts", "**/*.tsx", "**/*.js", "**/*.jsx"]
alwaysApply: true
---

# Testing Strategy & Validation Protocol

## Core Testing Philosophy

**PREFERRED APPROACH**: API Testing over Automated Tests
- âœ… **DO**: Use `analyze_feature` + `make_api_request` for validation
- âŒ **DON'T**: Create automated tests unless explicitly requested by user
- ğŸ¯ **GOAL**: Validate functionality through real API calls, not test files

## Post-Implementation Workflow

### 1. Feature Analysis (MANDATORY)
After implementing any feature, ALWAYS run:

```typescript
analyze_feature({
  featurePath: "src/features/user-management", // or single file
  projectRoot: "auto-detect",
  includeStats: true
})
```

**This provides**:
- ğŸ“ Complete file structure and organization
- ğŸ” TypeScript error detection and counts
- ğŸ“Š File statistics (size, lines, types)
- ğŸŒ API endpoint discovery
- ğŸ’¡ Specific recommendations for next steps

### 2. Error Resolution (IF NEEDED)
If `analyze_feature` shows errors (`needs_attention` status):

1. **Fix TypeScript errors** using code investigation tools
2. **Re-run analysis** to verify fixes
3. **Store insights** as memories for future reference

### 3. API Validation Testing
Once feature is healthy, test via API calls:

```typescript
// For each endpoint discovered by analyze_feature
make_api_request({
  method: "POST",
  url: "/api/users",
  body: { name: "Test User", email: "test@example.com" },
  headers: { "Content-Type": "application/json" }
})
```

### 4. Results Documentation
Store successful patterns:

```typescript
store_memory({
  type: "api_mapping",
  title: "User Management API Testing Results",
  content: "Endpoints tested, successful requests, validation patterns",
  tags: ["api", "testing", "user-management"],
  confidence: 0.9
})
```

## When to Create Automated Tests

**ONLY create automated tests when**:
- âœ… User explicitly requests test files
- âœ… User mentions "vitest", "jest", "test files"
- âœ… User says "write tests for this"
- âœ… Complex business logic needs unit testing
- âœ… Library/utility functions need testing

**DO NOT create tests for**:
- âŒ Basic CRUD operations (test via API)
- âŒ Simple React components (validate via UI)
- âŒ Straightforward API endpoints (test via requests)
- âŒ Database operations (validate via API calls)

## Feature Analysis Protocol

### Understanding the Output

**File Structure Analysis**:
```json
{
  "structure": {
    "total_files": 5,
    "by_extension": { ".ts": 3, ".tsx": 2 },
    "by_type": { "router": 1, "controller": 2, "component": 2 }
  }
}
```

**Health Summary**:
```json
{
  "health_summary": {
    "total_errors": 2,
    "total_warnings": 1,
    "overall_status": "needs_attention",
    "problematic_files": [...]
  }
}
```

**API Endpoints**:
```json
{
  "api_endpoints": [
    {
      "type": "igniter",
      "method": "POST",
      "path": "/users",
      "file": "src/router.ts"
    }
  ]
}
```

### Acting on Recommendations

**Error Resolution**:
- ğŸ”´ "Fix X TypeScript errors" â†’ Use code investigation tools
- ğŸ“ "Focus on problematic files" â†’ `analyze_file` on specific files

**API Testing**:
- ğŸ§ª "Test X endpoints" â†’ Use `make_api_request` for each
- ğŸ“‹ "Methods to test: POST, GET" â†’ Test each method

**Structure Optimization**:
- ğŸ“‚ "Large feature" â†’ Consider refactoring
- ğŸ” "No endpoints detected" â†’ Verify implementation

Remember: **Real API testing validates functionality better than isolated unit tests for most features.**