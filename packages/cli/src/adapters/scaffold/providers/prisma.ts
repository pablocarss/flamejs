import { getSchema, Model, Property } from '@mrleebo/prisma-ast';
import * as fs from 'fs/promises';
import * as path from 'path';
import { createChildLogger } from '../../logger';
import { ModelSchema, SchemaProvider, SchemaProviderField } from './base';

const logger = createChildLogger({ component: 'prisma-provider' });

/**
 * Maps Prisma data types to standard TypeScript types.
 * @param prismaType The type string from the Prisma schema (e.g., "String", "Int?", "DateTime").
 * @returns The corresponding TypeScript type as a string.
 */
function mapPrismaTypeToTsType(prismaType: string): string {
  const cleanType = prismaType.replace('?', '');
  switch (cleanType) {
    case 'String':
    case 'Json':
    case 'Bytes':
    case 'Unsupported':
      return 'string';
    case 'BigInt':
      return 'bigint';
    case 'Int':
    case 'Float':
    case 'Decimal':
      return 'number';
    case 'Boolean':
      return 'boolean';
    case 'DateTime':
      return 'Date';
    default:
      // This is likely a custom enum or a relation, which we treat as a string for simplicity in scaffolding.
      // The actual relation handling would be more complex.
      return 'string';
  }
}

/**
 * Checks if a property has a specific attribute decorator.
 * @param prop The schema property to check.
 * @param attributeName The name of the attribute (e.g., "id", "default").
 */
function hasAttribute(prop: Property, attributeName: string): boolean {
  if (prop.type !== 'field' || !Array.isArray(prop.attributes)) {
    return false;
  }
  return prop.attributes.some(attr => attr.name === attributeName);
}


/**
 * Implements the SchemaProvider interface for Prisma.
 * This class is responsible for reading a `schema.prisma` file and translating
 * its models into a standardized, ORM-agnostic format for the CLI.
 */
export class PrismaProvider implements SchemaProvider {
  private schemaPath: string;

  constructor(customPath?: string) {
    this.schemaPath = customPath || path.join(process.cwd(), 'prisma', 'schema.prisma');
    logger.debug(`Prisma schema path set to: ${this.schemaPath}`);
  }

  /**
   * Reads and parses the Prisma schema file to extract the details of a specific model.
   *
   * @param modelName - The name of the model to retrieve (e.g., 'User').
   * @returns A promise that resolves to the standardized `ModelSchema` or null if not found.
   */
  public async getModel(modelName: string): Promise<ModelSchema | null> {
    try {
      const schemaContent = await fs.readFile(this.schemaPath, 'utf-8');
      const ast = getSchema(schemaContent);

      const model = ast.list.find(
        (node): node is Model => node.type === 'model' && node.name === modelName
      );

      if (!model) {
        logger.warn(`Model '${modelName}' not found in schema.`);
        return null;
      }

      const fields: SchemaProviderField[] = model.properties
        .filter((prop): prop is Property => prop.type === 'field')
        .map((prop) => {
          // Type guard to ensure we have a field property with the expected structure
          if (prop.type !== 'field' || !('fieldType' in prop) || !('name' in prop)) {
            throw new Error(`Invalid field property structure for ${prop}`);
          }

          const fieldType = prop.fieldType as any;
          const fieldTypeStr = typeof fieldType === 'string' ? fieldType : fieldType?.toString() || 'string';
          const isOptional = 'optional' in prop ? (prop as any).optional : false;
          const isRelation = !/^[A-Z]/.test(fieldTypeStr) && typeof fieldType !== 'string';

          return {
            name: prop.name,
            type: mapPrismaTypeToTsType(fieldTypeStr),
            isId: hasAttribute(prop, 'id'),
            isRequired: !(isOptional || hasAttribute(prop, 'default')),
            isUnique: hasAttribute(prop, 'unique'),
            isRelation: isRelation,
            hasDefault: hasAttribute(prop, 'default'),
            isAutoGenerated: this.isFieldAutoGenerated(prop),
          };
        });

      return {
        name: model.name,
        fields,
      };

    } catch (error) {
      if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
        logger.error(`Prisma schema file not found at: ${this.schemaPath}`);
      } else {
        logger.error('Failed to parse Prisma schema', { error });
      }
      throw new Error(`Could not process Prisma schema. Make sure '${this.schemaPath}' exists and is valid.`);
    }
  }

  /**
   * Lists all available model names in the Prisma schema.
   *
   * @returns A promise that resolves to an array of model names.
   */
  public async listModels(): Promise<string[]> {
    try {
      const schemaContent = await fs.readFile(this.schemaPath, 'utf-8');
      const ast = getSchema(schemaContent);

      const models = ast.list
        .filter((node): node is Model => node.type === 'model')
        .map(model => model.name);

      logger.debug(`Found ${models.length} models in schema: ${models.join(', ')}`);
      return models;

    } catch (error) {
      if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
        logger.error(`Prisma schema file not found at: ${this.schemaPath}`);
        return [];
      } else {
        logger.error('Failed to parse Prisma schema for model listing', { error });
        throw new Error(`Could not process Prisma schema. Make sure '${this.schemaPath}' exists and is valid.`);
      }
    }
  }

  /**
   * Determines if a field's value is automatically managed by the database.
   *
   * @param prop - The schema property to inspect.
   * @returns True if the field is auto-generated.
   */
  private isFieldAutoGenerated(prop: Property): boolean {
    if (hasAttribute(prop, 'updatedAt')) {
      return true;
    }

    if (prop.type === 'field' && Array.isArray(prop.attributes)) {
      const defaultAttr = prop.attributes.find(attr => attr.name === 'default');
      if (defaultAttr && Array.isArray(defaultAttr.args)) {
        const defaultValue = defaultAttr.args[0]?.value;
        if (typeof defaultValue === 'string' && ['autoincrement()', 'now()', 'cuid()', 'uuid()'].includes(defaultValue)) {
          return true;
        }
      }
    }

    return false;
  }
}
